// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
//RWTexture2D<float4> Result;

RWStructuredBuffer<double> matrixAVals;
RWStructuredBuffer<double> matrixBVals;
RWStructuredBuffer<double> newMatVals;

RWStructuredBuffer<int> matrixADim;
RWStructuredBuffer<int> matrixBDim;
RWStructuredBuffer<int> newMatDim;

int index = 0;

int getFlatIndex(int hIndex, int wIndex, int dimy)
{
    return hIndex * dimy + wIndex;
}

void setNewMatValue(int hIndex, int wIndex, double val)
{
    newMatVals[getFlatIndex(hIndex, wIndex, newMatDim[1])] = val;
}

double getmatrixAValue(int hIndex, int wIndex)
{
    return matrixAVals[getFlatIndex(hIndex, wIndex, matrixADim[1])];
}

double getmatrixBValue(int hIndex, int wIndex)
{
    return matrixBVals[getFlatIndex(hIndex, wIndex, matrixBDim[1])];
}

double dotProduct(int hIndex, int wIndex)
{
    double result = 0;

    //Was matrixADim[1]
    for (int i = 0; i < matrixADim[1]; i++)
    {
        result = result + getmatrixAValue(hIndex, i) * getmatrixBValue(i, wIndex);
    }

    return result;
}

[numthreads(16, 8, 8)]
void CSMain(uint id : SV_GroupIndex)
{
    //Yeah SV_GroupIndex is exactly what we wanted
    
    //So from here let's do newMatrixVals[id3 ] = dotProduct(reverseCalc y, reverseCalc x)
    
    uint yIndex = id.x / newMatDim[1];
    
    uint xIndex = id.x % newMatDim[1];
    
    setNewMatValue(yIndex, xIndex, dotProduct(yIndex, xIndex));
}






